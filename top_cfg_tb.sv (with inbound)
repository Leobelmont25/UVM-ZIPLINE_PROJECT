`include "cr_global_params.vh"
`include "uvm_macros.svh"
import uvm_pkg::*;

module top_cfg_tb;

  // -------------------- clock/reset --------------------
  logic clk; logic rst_n;
  initial begin
    clk = 0;
    forever #0.625 clk = ~clk; // 800 MHz
  end
  initial begin
    rst_n = 0;
    #150; rst_n = 1;
  end

  // -------------------- AXIS inbound / outbound --------------------
  logic                         ib_tready;
  logic [`AXI_S_TID_WIDTH-1:0]  ib_tid;
  logic [`AXI_S_DP_DWIDTH-1:0]  ib_tdata;
  logic [`AXI_S_TSTRB_WIDTH-1:0] ib_tstrb;
  logic [`AXI_S_USER_WIDTH-1:0]  ib_tuser;
  logic                         ib_tvalid;
  logic                         ib_tlast;

  logic                         ob_tready;
  logic [`AXI_S_TID_WIDTH-1:0]  ob_tid;
  logic [`AXI_S_DP_DWIDTH-1:0]  ob_tdata;
  logic [`AXI_S_TSTRB_WIDTH-1:0] ob_tstrb;
  logic [`AXI_S_USER_WIDTH-1:0]  ob_tuser;
  logic                         ob_tvalid;
  logic                         ob_tlast;

  // -------------------- sch_update (DUT ?? master) --------------------
  logic                         sch_update_tready; // TB dirige
  logic [7:0]                   sch_update_tdata;  // DUT dirige
  logic                         sch_update_tvalid; // DUT dirige
  logic                         sch_update_tlast;  // DUT dirige
  logic [1:0]                   sch_update_tuser;  // DUT dirige

  // -------------------- outros --------------------
  logic                         engine_int, engine_idle;
  logic                         key_mode, dbg_cmd_disable, xp9_disable;

  // -------------------- APB IF --------------------
  apb_if #(.ADDR_W(`N_RBUS_ADDR_BITS), .DATA_W(`N_RBUS_DATA_BITS)) apb (.*);

  // -------------------- AXIS IFs p/ monitores --------------------
  axis_if #(.DATA_W(`AXI_S_DP_DWIDTH)) inb_if (.aclk(clk), .aresetn(rst_n));
  axis_if #(.DATA_W(`AXI_S_DP_DWIDTH)) out_if (.aclk(clk), .aresetn(rst_n));

  // Espelha p/ os IFs (somente para monitorar)
  assign inb_if.tvalid = ib_tvalid;
  assign inb_if.tlast  = ib_tlast;
  assign inb_if.tdata  = ib_tdata;
  assign inb_if.tready = ib_tready;

  assign out_if.tvalid = ob_tvalid;
  assign out_if.tlast  = ob_tlast;
  assign out_if.tdata  = ob_tdata;
  assign out_if.tready = ob_tready;

  // -------------------- DUT --------------------
  cr_cceip_64 dut(
    .ib_tready(ib_tready),
    .ib_tvalid(ib_tvalid),
    .ib_tlast(ib_tlast),
    .ib_tid(ib_tid),
    .ib_tstrb(ib_tstrb),
    .ib_tuser(ib_tuser),
    .ib_tdata(ib_tdata),

    .ob_tready(ob_tready),
    .ob_tvalid(ob_tvalid),
    .ob_tlast(ob_tlast),
    .ob_tid(ob_tid),
    .ob_tstrb(ob_tstrb),
    .ob_tuser(ob_tuser),
    .ob_tdata(ob_tdata),

    .sch_update_tready(sch_update_tready), // TB dirige
    .sch_update_tvalid(sch_update_tvalid), // DUT dirige
    .sch_update_tlast (sch_update_tlast ), // DUT dirige
    .sch_update_tuser (sch_update_tuser ), // DUT dirige
    .sch_update_tdata (sch_update_tdata ), // DUT dirige

    .apb_paddr(apb.paddr),
    .apb_psel(apb.psel),
    .apb_penable(apb.penable),
    .apb_pwrite(apb.pwrite),
    .apb_pwdata(apb.pwdata),
    .apb_prdata(apb.prdata),
    .apb_pready(apb.pready),
    .apb_pslverr(apb.pslverr),

    .clk(clk),
    .rst_n(rst_n),
    .key_mode(key_mode),
    .dbg_cmd_disable(dbg_cmd_disable),
    .xp9_disable(xp9_disable),
    .cceip_int(engine_int),
    .cceip_idle(engine_idle),
    .scan_en(1'b0),
    .scan_mode(1'b0),
    .scan_rst_n(1'b0),
    .ovstb(1'b1),
    .lvm(1'b0),
    .mlvm(1'b0)
  );

  // -------------------- Defaults --------------------
  initial begin
    key_mode = 1'b0; dbg_cmd_disable = 1'b0; xp9_disable = 1'b0;

    ib_tid=0; ib_tvalid=0; ib_tlast=0; ib_tdata='0; ib_tstrb='0; ib_tuser='0;
    ob_tready=1'b1;

    sch_update_tready = 1'b1; // somente ready; os demais v??m do DUT
  end

  // -------------------- UVM bring-up --------------------
  string testname, seed_str;
  initial begin
    if (!$value$plusargs("TESTNAME=%s", testname)) testname = "unknown";
    if (!$value$plusargs("SEED=%s",    seed_str))  seed_str  = "1";

    uvm_config_db#(virtual apb_if.mst)::set(null, "uvm_test_top.env.apb.m_driver", "vif", apb);
    uvm_config_db#(virtual apb_if.mst)::set(null, "uvm_test_top.env.apb", "vif_mst", apb);
    uvm_config_db#(virtual apb_if)::set(null,      "uvm_test_top.env.apb", "vif_mon", apb);

    uvm_config_db#(virtual axis_if.monitor)::set(null, "uvm_test_top.env.scb", "inb_vif", inb_if);
    uvm_config_db#(virtual axis_if.monitor)::set(null, "uvm_test_top.env.scb", "out_vif", out_if);

    uvm_config_db#(string)::set(null, "uvm_test_top", "testname", testname);
    uvm_root::get().finish_on_completion = 0;
    run_test("cfg_test");
  end

  // -------------------- Helpers --------------------
  function automatic int idx_of_char(string s, byte ch, int start);
    int i, n; byte c; n = s.len(); if (start < 0) start = 0;
    for (i = start; i < n; i++) begin c = s.getc(i); if (c == ch) return i; end
    return -1;
  endfunction

  function automatic string trim_ws(string s);
    int n, left_i, right_i; byte c; n = s.len(); right_i = n-1;
    while (right_i >= 0) begin c = s.getc(right_i);
      if (c==8'd32 || c==8'd9 || c==8'd10 || c==8'd13) right_i--; else break; end
    left_i = 0;
    while (left_i < n) begin c = s.getc(left_i);
      if (c==8'd32 || c==8'd9) left_i++; else break; end
    if (right_i < left_i) return ""; return s.substr(left_i, right_i);
  endfunction

  function automatic string to_lower_ascii(string s);
    int i, n; byte c; n = s.len();
    for (i=0;i<n;i++) begin c = s.getc(i);
      if (c >= 8'd65 && c <= 8'd90) s.putc(i, c + 8'd32); end
    return s;
  endfunction

  task automatic split_by_sep(string s, byte sep, ref string out_arr[$]);
    int i, n, start; string tok; n = s.len(); out_arr.delete(); start = 0;
    for (i=0; i<=n; i++) begin
      if (i==n || s.getc(i)==sep) begin
        if (i==0) tok = ""; else tok = s.substr(start, i-1);
        tok = trim_ws(tok); out_arr.push_back(tok); start = i+1;
      end
    end
  endtask

  function automatic string safe_substr(string s, int start, int end_i);
    int n; n = s.len(); if (start < 0) start = 0; if (end_i >= n) end_i = n-1;
    if (end_i < start) return ""; return s.substr(start, end_i);
  endfunction

  function automatic bit [`AXI_S_DP_DWIDTH-1:0] hex_to_word(string s);
    bit [`AXI_S_DP_DWIDTH-1:0] w; string t; w = '0; t = to_lower_ascii(trim_ws(s));
    if (t.len()>=2 && t.substr(0,1)=="0x") t = t.substr(2, t.len()-1);
    void'($sscanf(t, "%h", w)); return w;
  endfunction

  // -------------------- INBOUND pump (com SoT/EoT em tuser) --------------------
  task automatic send_inbound_from_file(string path);
    int fd, i, eq, sp, pos, dbg_cnt, rc;
    string line_raw, line, low, rest, key, val;
    string token; bit [`AXI_S_DP_DWIDTH-1:0] data_word; int last_val;
    int is_csv, csv_idx_data, csv_idx_last; string fields[$], cols[$];
    byte CH_COMMA, CH_SEMI, CH_EQ, CH_SPACE; string t0, t1, t2, t1_low;
    int in_pkt;

    data_word='0; last_val=0; is_csv=0; csv_idx_data=-1; csv_idx_last=-1; dbg_cnt=0; in_pkt=0;
    CH_COMMA=8'd44; CH_SEMI=8'd59; CH_EQ=8'd61; CH_SPACE=8'd32;

    fd = $fopen(path, "r"); if (fd == 0) begin $display("[%0t] INB_PUMP: nao abriu arquivo %s", $time, path); return; end
    if (!$feof(fd)) begin
      void'($fgets(line_raw, fd)); line = trim_ws(line_raw); low  = to_lower_ascii(line);
      if (idx_of_char(low, CH_COMMA, 0) != -1 || idx_of_char(low, CH_SEMI, 0) != -1) begin
        split_by_sep(low, (idx_of_char(low, CH_COMMA, 0)!=-1)?CH_COMMA:CH_SEMI, fields);
        for (i=0;i<fields.size();i++) begin
          if (fields[i]=="data") csv_idx_data=i; if (fields[i]=="last") csv_idx_last=i; end
        if (csv_idx_data!=-1) is_csv=1;
      end end
    $fclose(fd);

    fd = $fopen(path, "r"); if (fd == 0) begin $display("[%0t] INB_PUMP: nao reabriu arquivo %s", $time, path); return; end
    ib_tvalid=1'b0; ib_tlast=1'b0; ib_tdata='0; ib_tstrb='0; ib_tuser='0; in_pkt=0;

    while (!$feof(fd)) begin
      void'($fgets(line_raw, fd)); line = trim_ws(line_raw);

      // linha em branco => fecha pacote
      if (line.len() == 0) begin
        if (ib_tvalid) begin
          @(posedge clk);
          ib_tlast  = 1'b1;
          ib_tstrb  = {`AXI_S_TSTRB_WIDTH{1'b1}};
          ib_tuser[1] = 1'b1; // EoT
          do @(posedge clk); while(!(ib_tvalid && ib_tready));
          ib_tvalid = 1'b0;
          ib_tlast  = 1'b0;
          ib_tstrb  = '0;
          ib_tuser  = '0;
          in_pkt    = 0;
        end
        continue;
      end

      // parse
      if (is_csv) begin
        split_by_sep(line, (idx_of_char(line, CH_COMMA, 0)!=-1)?CH_COMMA:CH_SEMI, cols);
        if (cols.size()==0) continue;
        data_word = hex_to_word(cols[csv_idx_data]);
        if (csv_idx_last!=-1) begin low = to_lower_ascii(trim_ws(cols[csv_idx_last])); last_val = (low=="1"); end
        else last_val = 0;
      end else begin
        t0=""; t1=""; t2=""; rc = $sscanf(line, "%s %s %s", t0, t1, t2);
        if (rc >= 1 && (t0.len() > 0)) begin
          t1_low = to_lower_ascii(t1);
          if ( (rc >= 2) && (t1_low == "sot" || t1_low == "eot" || t1_low == "sot-eot") ) begin
            data_word = hex_to_word(t0);
            last_val  = (t1_low == "eot") || (t1_low == "sot-eot");
          end else begin
            low = to_lower_ascii(line); rest = low; data_word = hex_to_word(low); last_val  = 0;
            pos = idx_of_char(rest, CH_EQ, 0);
            while (pos != -1) begin
              eq  = pos; key = trim_ws( safe_substr(rest, 0, eq-1) );
              sp  = idx_of_char(rest, CH_SPACE, eq+1); if (sp == -1) sp = rest.len();
              val = trim_ws( safe_substr(rest, eq+1, sp-1) );
              if (sp < rest.len()) rest = trim_ws( safe_substr(rest, sp+1, rest.len()-1) );
              else rest = "";
              if (key=="data") data_word = hex_to_word(val);
              else if (key=="last") last_val = (to_lower_ascii(val)=="1");
              pos = idx_of_char(rest, CH_EQ, 0);
            end
          end
        end
      end

      // drive
      @(posedge clk);
      ib_tdata  = data_word;
      ib_tvalid = 1'b1;
      ib_tlast  = last_val;
      ib_tstrb  = {`AXI_S_TSTRB_WIDTH{1'b1}};
      if (!in_pkt) begin
        ib_tuser = '0;
        ib_tuser[0] = 1'b1;  // SoT
        in_pkt = 1;
      end else begin
        ib_tuser = '0;       // batida intermedi??ria
      end
      if (last_val) ib_tuser[1] = 1'b1; // EoT no ??ltimo beat

      do @(posedge clk); while(!(ib_tvalid && ib_tready));

      if (ib_tlast) begin
        ib_tvalid = 1'b0;
        ib_tlast  = 1'b0;
        ib_tstrb  = '0;
        ib_tuser  = '0;
        in_pkt    = 0;
      end
    end

    // flush final se necess??rio
    if (ib_tvalid) begin
      @(posedge clk);
      ib_tlast  = 1'b1;
      ib_tstrb  = {`AXI_S_TSTRB_WIDTH{1'b1}};
      ib_tuser[1] = 1'b1;
      do @(posedge clk); while(!(ib_tvalid && ib_tready));
      ib_tvalid = 1'b0;
      ib_tlast  = 1'b0;
      ib_tstrb  = '0;
      ib_tuser  = '0;
      in_pkt    = 0;
    end
    $fclose(fd);
  endtask

  // -------------------- OUTBOUND check (opcional) --------------------
  task automatic check_outbound_against_file(string path);
    int fd, i, eq, sp, pos; string line_raw, line, low, rest, key, val;
    string cols[$], fields[$]; bit [`AXI_S_DP_DWIDTH-1:0] exp_word;
    int exp_last, is_csv, csv_idx_data, csv_idx_last;
    byte CH_COMMA, CH_SEMI, CH_EQ, CH_SPACE; exp_word='0; exp_last=0; is_csv=0; csv_idx_data=-1; csv_idx_last=-1;
    CH_COMMA=8'd44; CH_SEMI=8'd59; CH_EQ=8'd61; CH_SPACE=8'd32;

    fd = $fopen(path, "r"); if (fd == 0) begin $display("[%0t] OUT_CHK: nao abriu arquivo %s", $time, path); return; end
    if (!$feof(fd)) begin
      void'($fgets(line_raw, fd)); line = trim_ws(line_raw); low  = to_lower_ascii(line);
      if (idx_of_char(low, CH_COMMA, 0) != -1 || idx_of_char(low, CH_SEMI, 0) != -1) begin
        split_by_sep(low, (idx_of_char(low, CH_COMMA, 0)!=-1)?CH_COMMA:CH_SEMI, fields);
        for (i=0;i<fields.size();i++) begin if (fields[i]=="data") csv_idx_data=i; if (fields[i]=="last") csv_idx_last=i; end
        if (csv_idx_data!=-1) is_csv=1;
      end end
    $fclose(fd);

    fd = $fopen(path, "r"); if (fd == 0) begin $display("[%0t] OUT_CHK: nao reabriu arquivo %s", $time, path); return; end

    forever begin
      do @(posedge clk); while(!(ob_tvalid && ob_tready));
      do begin
        if ($feof(fd)) begin $display("[%0t] OUT_CHK: DUT emitiu mais dados que o arquivo", $time); $fclose(fd); return; end
        void'($fgets(line_raw, fd)); line = trim_ws(line_raw);
      end while (line.len()==0 && !is_csv);

      if (is_csv) begin
        split_by_sep(line, (idx_of_char(line, CH_COMMA, 0)!=-1)?CH_COMMA:CH_SEMI, cols);
        exp_word = hex_to_word(cols[csv_idx_data]);
        if (csv_idx_last!=-1) begin low = to_lower_ascii(trim_ws(cols[csv_idx_last])); exp_last = (low=="1"); end
        else exp_last = 0;
      end else begin
        low = to_lower_ascii(line); rest = low; exp_word = hex_to_word(low); exp_last = 0;
        pos = idx_of_char(rest, CH_EQ, 0);
        while (pos != -1) begin
          eq  = pos; key = trim_ws( safe_substr(rest, 0, eq-1) );
          sp  = idx_of_char(rest, CH_SPACE, eq+1); if (sp == -1) sp = rest.len();
          val = trim_ws( safe_substr(rest, eq+1, sp-1) );
          if (sp < rest.len()) rest = trim_ws( safe_substr(rest, sp+1, rest.len()-1) );
          else rest = "";
          if (key=="data") exp_word = hex_to_word(val);
          else if (key=="last") exp_last = (to_lower_ascii(val)=="1");
          pos = idx_of_char(rest, CH_EQ, 0);
        end
      end

      if (ob_tdata !== exp_word || ob_tlast !== exp_last) begin
        $display("[%0t] OUT_CHK MISMATCH: got data=%h last=%0d  exp data=%h last=%0d",
                 $time, ob_tdata, ob_tlast, exp_word, exp_last);
      end
    end
  endtask

  // -------------------- Tr??fego (inbound + log outbound) --------------------
  initial begin
    ob_tready = 1'b1;         // sempre pronto para consumir o outbound
    wait (rst_n == 1);
    repeat (2000) @(posedge clk);

    fork
      // INBOUND: injeta arquivo quando o DUT anunciar pronto
      begin : start_inbound_after_ready
        int unsigned timeout = 10_000_000;
        int unsigned cnt = 0;
        while (!ib_tready && cnt < timeout) begin
          @(posedge clk);
          cnt++;
        end
        repeat (2_000_000) @(posedge clk);
        send_inbound_from_file("../tests/xp10.inbound");
      end

      // OUTBOUND: loga cada batida emitida pelo DUT
      begin : monitor_outbound
        forever begin
          @(posedge clk);
          if (ob_tvalid && ob_tready) begin
            $display("[%0t] OUT_BEAT: data=%h last=%0d", $time, ob_tdata, ob_tlast);
          end
        end
      end
    join_none

    // tempo total de simula????o
    repeat (12_000_000) @(posedge clk);
    $finish;
  end

  // -------------------- Tap do sch_update (observa????o) --------------------
  initial begin : monitor_sch_update
    forever begin
      @(posedge clk);
      if (sch_update_tvalid && sch_update_tready) begin
        $display("[%0t] SCH_UPDATE: data=%02h last=%0d user=%0d",
                 $time, sch_update_tdata, sch_update_tlast, sch_update_tuser);
      end
    end
  end

endmodule
